Каждому процессу доступны по меньшей мере три информационных канала: “стан­
дартный ввод” (STDIN), “стандартный вывод” (STDOUT) и “стандартная ошибка”
(STDERR). Эти каналы устанавливаются ядром системы “от имени процесса”, и поэ­
тому сам процесс не обязательно знает их направленность. Они, например, могут быть
связаны с окном терминала, файлом, подключением к сети или с каналом, принадлежа­
щим к другому процессу.
Для систем UNIX используется унифицированная модель ввода-вывода, в которой
каждому каналу присваивается целое число, именуемое файловым дескриптором. Точное
число (номер), назначаемое каналу, обычно не имеет значения, но каналам STDIN,
STDOUT и STDERR гарантированно соответствуют файловые дескрипторы 0, 1 и 2 со­
ответственно, чтобы обеспечить безопасное обращение к ним по номерам. В контексте
интерактивного окна терминала канал STDIN обычно считывает данные с клавиатуры,
а оба канала STDOUT и STDERR записывают свои выходные данные на экран.
Большинство команд принимает входные данные из канала STDIN. Выходная ин­
формация записывается ими в канал STDOUT, а сообщения об ошибках — в канал
STDERR. Это соглашение позволяет объединять команды подобно строительным бло­
кам для организации конвейерной обработки данных.


Командная оболочка интерпретирует символы “<”, “>” и “>>” как инструкции по
изменению направления передаваемых командой данных в файл или принимаемых
данных из файла. Символ “<” связывает канал STDIN с содержимым некоторого суще­
ствующего файла. Символы “>” и “>>” перенаправляют поток STDOUT; причем символ
“>” используется для замены содержимого файла, а “>>” — для добавления данных в его
конец. Например, команда
$ echo "Это тестовое сообщение." > /tmp/mymessage
сохраняет одну строку в файле /tmp/mymessage (при необходимости файл будет соз­
дан). Следующая команда отправляет содержимое этого файла по электронной почте
пользователю johndoe .
$ mail -s "Mail test" johndoe < /tmp/mymessage
Для того чтобы перенаправить потоки STDOUT и STDERR в одно и то же место, ис­
пользуйте символ “>&”. Для того чтобы перенаправить только поток STDERR, исполь­
зуйте вариант “2>”.
На примере команды find можно показать, почему важно обрабатывать потоки
STDOUT и STDERR отдельно. Дело в том, что она формирует выходные данные по обо­
им каналам, особенно в случае ее выполнения непривилегированным пользователем.
Например, при выполнении команды
$ find / -name core
обычно генерируется так много сообщений об ошибках “permission denied” (отсутствие
прав доступа), что настоящие результаты поиска теряются в “шуме”. Чтобы отбросить
все сообщения об ошибках, можно использовать такой вариант.
$ find / -name core 2> /dev/null


Скрипты
Для выполнения этой программы установите “исполнительный” бит или вызовите
напрямую интерпретатор языка Python.
$ chmod +х helloworld
Объекты, строки, числа, списки,
словари, кортежи и файлы
Все типы данных в языке Python являются объектами, и это придает им больше силы
и гибкости, чем в языке Perl.
В языке Python списки заключаются в квадратные скобки (а не в круглые). Индек­
сация массивов начинается с нуля (это один из немногочисленных принципов, который
не меняется для всех трех “сценарных” языков, рассматриваемых в этой главе).
“Новым словом” в языке Python прозвучали “кортежи,” которые, по сути, представ­
ляют собой неизменяемые списки. Кортежи работают быстрее, чем массивы, и оказыва­
ются весьма полезными для представления данных, которые должны быть немодифици-
рованными. Синтаксис для кортежей такой же, как для списков, за исключением того,
что разделителями у них служат круглые скобки (а не квадратные). Поскольку запись
( thing ) похожа на простое алгебраическое выражение, кортежи, содержащие только
один элемент, должны иметь дополнительную запятую, которая не оставит у вас сомне­
ний, с чем именно вы имеете дело, — ( thing, ) .
Рассмотрите пример использования некоторых основных типов данных в языке
Python.
#!/usr/bin/python
name = 'Gwen'
rating = 10
characters = [ 'ГубкаБоб', 'Патрик', 'Сквидвард' ]
elements = ( 'литий', 'углерод', 'бор' )
print "Имя:\t%s\nРейтинг:\t%d" % (name, rating)
print "Герои:\t%s" % characters
print "Элементы:\t%s" % (elements, )
Вот как выглядит результат выполнения этого примера.
$ python objects
Имя:
Gwen
Рейтинг:
10
Герои:
['ГубкаБоб', 'Патрик', 'Сквидвард' ]
Элементы:
('литий', 'углерод', 'бор')
Переменные в языке Python не отмечаются синтаксически и не объявляются с указа­
нием типа, но объекты, на которые они ссылаются, имеют базовый тип. В большинстве
случаев язык Python автоматически не преобразует типы за вас, но это могут сделать
отдельные функции или операторы. Например, вы не можете сцепить строку и число
(с помощью оператора “+”) без явного преобразования числа в его строковое представ­
ление. Однако операторы форматирования приводят объекты любого типа к строковому
виду. Каждый объект имеет строковое представление.
Действие оператора строкового форматирования “ % ” во многом подобно действию
функции sprintf из языков С или Perl, но его можно использовать везде, где может
находиться строка. Это бинарный оператор, в левой части которого стоит строка, а в112
Часть I. Основы администрирования
правой — вставляемые значения. Если вставляемых значений несколько, они должны
быть представлены в виде кортежа.
Словарь в языке Python — это то же самое, что хеш в языке Perl, т.е. список пар
“ключ/значение”. Словарные литералы заключаются в фигурные скобки, а элементы,
составляющие пару “ключ/значение”, отделяются друг от друга двоеточием.
#!/usr/bin/python
ordinal = { 1 : 'первый', 2 : 'второй', 3 : 'третий' }
print "Массив ordinal содержит", ordinal
print "Значением ordinal для ключа 1 является", ordinal[1]
На практике Python-словари во многом подобны массивам, за исключением того,
что “словарные” индексы (ключи) могут быть объектами, отличными от целых чисел.
$ python dictionary
Массив ordinal содержит {1: 'первый', 2: 'второй', 3: 'третий'}
Значением ordinal для ключа 1 является первый
В языке Python файлы открываются как объекты с помощью соответствующих ме­
тодов. Метод readline , вполне оправдывая свое имя, считывает одну строку. При вы­
полнении приведенного ниже примера считываются (и выводятся) две строки из файла
/ etc/passwd .
#!/usr/bin/python
f = open('/etc/passwd', 'r')
print f.readline(),
print f.readline(),
f.close ()
$ python fileio
at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/true
bin:x:1:1:bin:/bin:/bin/true
Замыкающие запятые в операторах print используются для подавления символов
новой строки, поскольку каждая строка и так уже включает этот символ, считанный из
исходного файла.
